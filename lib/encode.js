// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var C, encode, encode_json, encode_json_obj, encode_msgpack, fix_encoding, purepack;

  purepack = require('purepack');

  C = require('./const').C;

  fix_encoding = function(e) {
    if ((e == null) || !C.encodings.codes[e]) {
      e = 'json';
    }
    return e;
  };

  exports.encode = encode = function(_arg) {
    var encoding, obj, out;
    obj = _arg.obj, encoding = _arg.encoding;
    encoding = fix_encoding(encoding);
    out = encoding === 'msgpack' || encoding === 'msgpack64' ? encode_msgpack({
      obj: obj,
      encoding: encoding
    }) : encode_json(obj);
    if (!Buffer.isBuffer(out)) {
      out = new Buffer(out, 'utf8');
    }
    return out;
  };

  exports.self_describing_encode = function(_arg) {
    var encoding, obj;
    obj = _arg.obj, encoding = _arg.encoding;
    encoding = fix_encoding(encoding);
    return Buffer.concat([
      new Buffer([C.version.V1, C.encodings.codes[encoding]]), encode({
        obj: obj,
        encoding: encoding
      })
    ]);
  };

  encode_json = function(obj) {
    var o2;
    o2 = encode_json_obj(obj);
    return JSON.stringify(o2);
  };

  encode_msgpack = function(_arg) {
    var encoding, o2, obj;
    obj = _arg.obj, encoding = _arg.encoding;
    o2 = purepack.pack(obj);
    if (encoding === 'msgpack64') {
      return o2.toString('base64');
    } else {
      return o2;
    }
  };

  exports.encode_json_obj = encode_json_obj = function(o) {
    var _encode_json_obj, _is_hex_key;
    _is_hex_key = function(key) {
      return key != null ? key.match(/(^|_)(fingerprint|u?id)s?$/) : void 0;
    };
    _encode_json_obj = function(o, last_key) {
      var e, k, out, v, _i, _len, _results;
      if (typeof o !== 'object') {
        return o;
      } else if (Array.isArray(o)) {
        _results = [];
        for (_i = 0, _len = o.length; _i < _len; _i++) {
          e = o[_i];
          _results.push(_encode_json_obj(e, last_key));
        }
        return _results;
      } else if (Buffer.isBuffer(o)) {
        if (_is_hex_key(last_key)) {
          return {
            __h: o.toString('hex')
          };
        } else {
          return {
            __b: o.toString('base64')
          };
        }
      } else {
        out = {};
        for (k in o) {
          v = o[k];
          out[k] = _encode_json_obj(v, k);
        }
        return out;
      }
    };
    return _encode_json_obj(o, null);
  };

}).call(this);
